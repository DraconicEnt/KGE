/**
 *  @file SSettingsRegistry.cpp
 */

#include <allegro5/allegro.h>

#include <support/Console.hpp>
#include <support/common.hpp>
#include <support/String.hpp>
#include <support/support.hpp>

#include <support/SSettingsRegistry.hpp>

namespace Kiaro
{
    namespace Support
    {
        void SSettingsRegistry::setDefaultValues(void)
        {
            this->setValue("Server::ListenAddress", Support::String("0.0.0.0"));
            this->setValue<Common::U16>("Server::ListenPort", 11595);
            this->setValue<Common::U32>("Server::MaximumClientCount", 32);
            this->setValue<bool>("Video::Fullscreen", false);
            this->setValue<irr::core::dimension2d<Common::U32>>("Video::Resolution", irr::core::dimension2d<Common::U32>(640, 480));
            this->setValue<Common::U16>("Video::ActiveFPS", 60);
            this->setValue<Common::U16>("Video::InactiveFPS", 15);
            this->setValue<Common::U8>("System::WorkerThreadCount", 6);
        }

        SSettingsRegistry::SSettingsRegistry(void)
        {
            this->setDefaultValues();
            ALLEGRO_CONFIG* config = al_load_config_file("config.cfg");

            if (!config)
                CONSOLE_ERROR("Failed to load config.cfg, using default values.");
            else
            {
                // Blow through each config section
                ALLEGRO_CONFIG_SECTION* configSection;
                const Common::C8* configSectionName = al_get_first_config_section(config, &configSection);

                while (configSectionName != nullptr)
                {
                    Support::String variableBaseName = configSectionName;

                    ALLEGRO_CONFIG_ENTRY* configEntry;
                    const Common::C8* configEntryName = al_get_first_config_entry(config, configSectionName, &configEntry);

                    while (configEntryName != nullptr)
                    {
                        Support::String variableName = variableBaseName + "::";
                        variableName += configEntryName;

                        // Set values
                        const Common::C8* configValue = al_get_config_value(config, configSectionName, configEntryName);

                        // TODO: Actually resolve types?
                        this->setStringValue(variableName.data(), Support::String(configValue));

                        // Get the next entry
                        configEntryName = al_get_next_config_entry(&configEntry);
                    }

                    // Get the next section
                    configSectionName = al_get_next_config_section(&configSection);
                }

                al_destroy_config(config);
                CONSOLE_INFO("SSettingsRegistry: Loaded config.cfg.");
            }
        }

        SSettingsRegistry::~SSettingsRegistry(void)
        {
            // Dump our current config to the file before destroying
            ALLEGRO_CONFIG* config = al_create_config();

            if (config)
            {
                Common::C8 tempBuffer[256];
                sprintf(tempBuffer, "Automatically generated by KGE %u.%u.%u", VERSION::MAJOR, VERSION::MINOR, VERSION::REVISION);
                // Header comments---------------------
                al_add_config_comment(config, NULL, "Configuration values for the operation of the KGE");
                al_add_config_comment(config, NULL, tempBuffer);

                // Write server section----------------
                al_add_config_section(config, "Server");
                al_add_config_comment(config, "Server", "Configuration values for the server end");
                al_add_config_comment(config, "Server", "ListenAddress specifies what IP address the server will bind to");
                al_set_config_value(config, "Server", "ListenAddress", this->getValue<Support::String>("Server::ListenAddress").data());

                // Listen Port
                sprintf(tempBuffer, "%u", this->getValue<Common::U16>("Server::ListenPort"));
                al_add_config_comment(config, "Server", "ListenPort specifies what port number the server will listen on");
                al_set_config_value(config, "Server", "ListenPort", tempBuffer);

                // Maximum Client Count
                sprintf(tempBuffer, "%u", this->getValue<Common::U32>("Server::MaximumClientCount"));
                al_add_config_comment(config, "Server", "MaximumClientCount specifies the maximum number of remote clients allowed");
                al_set_config_value(config, "Server", "MaximumClientCount", tempBuffer);

                // Write video section-----------------------
                al_add_config_section(config, "Video");
                al_add_config_comment(config, "Video", "Video output configuration");
                al_add_config_comment(config, "Video", "Resolution controls the window resolution of the engine");
                Support::Dimension2DU resolution = this->getValue<Support::Dimension2DU>("Video::Resolution");

                sprintf(tempBuffer, "%ux%u", resolution.Width, resolution.Height);
                al_set_config_value(config, "Video", "Resolution", tempBuffer);
                al_add_config_comment(config, "Video", "Fullscreen controls whether or not the engine will run full screen");
                al_set_config_value(config, "Video", "Fullscreen", this->getValue<bool>("Video::Fullscreen") ? "1" : "0");

                sprintf(tempBuffer, "%u", this->getValue<Common::U16>("Video::InactiveFPS"));
                al_add_config_comment(config, "Video", "Inactive FPS determines what framerate the engine will render at when the window is inactive.");
                al_add_config_comment(config, "Video", "Setting this to a high value does not guarantee that FPS to actually be achieved.");
                al_add_config_comment(config, "Video", "This should generally be a low value to help system performance when the game isn't focused.");
                al_set_config_value(config, "Video", "InactiveFPS", tempBuffer);

                sprintf(tempBuffer, "%u", this->getValue<Common::U16>("Video::ActiveFPS"));
                al_add_config_comment(config, "Video", "Active FPS determines what framerate the engine will render at when the window is active.");
                al_add_config_comment(config, "Video", "Setting this to a high value does not guarantee that FPS to actually be achieved.");
                al_set_config_value(config, "Video", "ActiveFPS", tempBuffer);

                // Write system section----------------------
                al_add_config_section(config, "System");
                al_add_config_comment(config, "System", "Core system configuration.");

                // Worker Thread Count
                sprintf(tempBuffer, "%u", this->getValue<Common::U8>("System::WorkerThreadCount"));
                al_add_config_comment(config, "System", "WorkerThreadCount dictates how many worker threads will be created for the asynchronous task manager");
                al_add_config_comment(config, "System", "If WorkerThreadCount=0 then the async tasker is disabled and such tasks will be handled synchronously");
                al_set_config_value(config, "System", "WorkerThreadCount", tempBuffer);

                // We're done
                al_save_config_file("config.cfg", config);
                al_destroy_config(config);
                CONSOLE_INFO("Wrote new configuration file.");
            }
            else
                CONSOLE_ERROR("Failed to acquire Allegro config handle!");

            // Make sure we clear the heap elements
            for (auto it = mStoredProperties.begin(); it != mStoredProperties.end(); it++)
                free(it->second.first);
        }

        void SSettingsRegistry::setStringValue(const Support::String& name, const Support::String& value)
        {
            // Does an entry exist?
            auto searchResult = mStoredProperties.find(name);
            if (searchResult != mStoredProperties.end() && ((*searchResult).second.second) == Support::PROPERTY_STRING)
            {
                this->setValue<Support::String>(name, value);
                return;
            }

            static const Support::Regex numberRegex("[0-9]+", Support::RegexConstants::Extended);
            static const Support::Regex resolutionRegex("[0-9]+x[0-9]+", Support::RegexConstants::Extended);
            static const Support::Regex addressRegex("[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}", Support::RegexConstants::Extended);

            // What is the type of the existing entry?
            const Support::PROPERTY_TYPE typeID = (*searchResult).second.second;

            switch(typeID)
            {
                case Support::PROPERTY_BOOL:
                {
                    if (!Support::RegexMatch(value.data(), numberRegex))
                    {
                        CONSOLE_ERRORF("Failed to read config value as bool: '%s'. Using default value.", name.data());
                        break;
                    }

                    this->setValue<bool>(name.data(), atoi(value.data()));
                    break;
                }

                case Support::PROPERTY_U64:
                {
                    if (!Support::RegexMatch(value.data(), numberRegex))
                    {
                        CONSOLE_ERRORF("Failed to read config value as U64: '%s'. Using default value.", name.data());
                        break;
                    }

                    this->setValue<Common::U64>(name.data(), atoi(value.data()));
                    break;
                }

                case Support::PROPERTY_U32:
                {
                    if (!Support::RegexMatch(value.data(), numberRegex))
                    {
                        CONSOLE_ERRORF("Failed to read config value as U32: '%s'. Using default value.", name.data());
                        break;
                    }

                    this->setValue<Common::U32>(name.data(), atoi(value.data()));
                    break;
                }

                case Support::PROPERTY_U8:
                {
                    if (!Support::RegexMatch(value.data(), numberRegex))
                    {
                        CONSOLE_ERRORF("Failed to read config value as U8: '%s'. Using default value.", name.data());
                        break;
                    }

                    this->setValue<Common::U8>(name.data(), atoi(value.data()));
                    break;
                }

                case Support::PROPERTY_U16:
                {
                    if (!Support::RegexMatch(value.data(), numberRegex))
                    {
                        CONSOLE_ERRORF("Failed to read config value as U16: '%s'. Using default value.", name.data());
                        break;
                    }

                    this->setValue<Common::U16>(name.data(), atoi(value.data()));
                    break;
                }

                case Support::PROPERTY_DIMENSION:
                {
                    if (!Support::RegexMatch(value.data(), resolutionRegex))
                    {
                        CONSOLE_ERRORF("Failed to read config value as dimensions: '%s'. Using default value.", name.data());
                        break;
                    }

                    const size_t splitLocation = value.find("x");
                    const Support::String widthString = value.substr(0, splitLocation);
                    const Support::String heightString = value.substr(splitLocation + 1, value.length());

                    this->setValue<Support::Dimension2DU>(name.data(), Support::Dimension2DU(atoi(widthString.data()), atoi(heightString.data())));
                    break;
                }

                case Support::PROPERTY_STRING:
                {
                    break;
                }

                default:
                {
                    CONSOLE_ERROR("Encountered type");
                    break;
                }
            }
        }
    } // End NameSpace Core
} // End NameSpace Kiaro
